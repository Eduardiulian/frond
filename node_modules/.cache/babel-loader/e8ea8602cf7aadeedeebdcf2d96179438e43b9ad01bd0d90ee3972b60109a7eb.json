{"ast":null,"code":"const RENDER_DELAY = 100;\nconst gameUpdates = [];\nlet gameStart = 0;\nlet firstServerTimestamp = 0;\nexport function initState() {\n  gameStart = 0;\n  firstServerTimestamp = 0;\n}\nexport function processGameUpdate(update) {\n  if (!firstServerTimestamp) {\n    firstServerTimestamp = update.t;\n    gameStart = Date.now();\n  }\n  gameUpdates.push(update);\n  const base = getBaseUpdate();\n  if (base > 0) {\n    gameUpdates.splice(0, base);\n  }\n}\nfunction currentServerTime() {\n  return firstServerTimestamp + (Date.now() - gameStart) - RENDER_DELAY;\n}\nfunction getBaseUpdate() {\n  const serverTime = currentServerTime();\n  for (let i = gameUpdates.length - 1; i >= 0; i--) {\n    if (gameUpdates[i].t <= serverTime) {\n      return i;\n    }\n  }\n  return -1;\n}\nexport function getCurrentState() {\n  if (!firstServerTimestamp) {\n    return {};\n  }\n  const base = getBaseUpdate();\n  // If base is the most recent update we have, use its state.\n  // Otherwise, interpolate between its state and the state of (base + 1).\n  if (base < 0 || base === gameUpdates.length - 1) {\n    return gameUpdates[gameUpdates.length - 1];\n  } else {\n    const baseUpdate = gameUpdates[base];\n    return {\n      me: baseUpdate.me,\n      others: baseUpdate.others,\n      lines: baseUpdate.lines,\n      remainders: baseUpdate.remainders\n    };\n  }\n}\n\n//function interpolateObject(object1, object2, ratio) {\n//  if (!object2) {\n//    return object1;\n//  }\n//\n//  const interpolated = {};\n//  Object.keys(object1).forEach(key => {\n//    if (key === 'direction') {\n//      interpolated[key] = interpolateDirection(object1[key], object2[key], ratio);\n//    } else {\n//      interpolated[key] = object1[key] + (object2[key] - object1[key]) * ratio;\n//    }\n//  });\n//  return interpolated;\n//}\n//\n//function interpolateObjectArray(objects1, objects2, ratio) {\n//  return objects1.map(o => interpolateObject(o, objects2.find(o2 => o.id === o2.id), ratio));\n//}\n\n//function interpolateDirection(d1, d2, ratio) {\n//  const absD = Math.abs(d2 - d1);\n//  if (absD >= Math.PI) {\n//    // The angle between the directions is large - we should rotate the other way\n//    if (d1 > d2) {\n//      return d1 + (d2 + 2 * Math.PI - d1) * ratio;\n//    } else {\n//      return d1 - (d2 - 2 * Math.PI - d1) * ratio;\n//    }\n//  } else {\n//    // Normal interp\n//    return d1 + (d2 - d1) * ratio;\n//  }\n//}","map":{"version":3,"names":["RENDER_DELAY","gameUpdates","gameStart","firstServerTimestamp","initState","processGameUpdate","update","t","Date","now","push","base","getBaseUpdate","splice","currentServerTime","serverTime","i","length","getCurrentState","baseUpdate","me","others","lines","remainders"],"sources":["/home/edi/onion/frondend/src/game/state.js"],"sourcesContent":["const RENDER_DELAY = 100;\n\nconst gameUpdates = [];\nlet gameStart = 0;\nlet firstServerTimestamp = 0;\n\nexport function initState() {\n  gameStart = 0;\n  firstServerTimestamp = 0;\n}\n\nexport function processGameUpdate(update) {\n  if (!firstServerTimestamp) {\n    firstServerTimestamp = update.t;\n    gameStart = Date.now();\n  }\n  gameUpdates.push(update);\n  const base = getBaseUpdate();\n  if (base > 0) {\n    gameUpdates.splice(0, base);\n  }\n}\n\nfunction currentServerTime() {\n  return firstServerTimestamp + (Date.now() - gameStart) - RENDER_DELAY;\n}\n\n\nfunction getBaseUpdate() {\n  const serverTime = currentServerTime();\n  for (let i = gameUpdates.length - 1; i >= 0; i--) {\n    if (gameUpdates[i].t <= serverTime) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\nexport function getCurrentState() {\n  if (!firstServerTimestamp) {\n    return {};\n  }\n  const base = getBaseUpdate();\n  // If base is the most recent update we have, use its state.\n  // Otherwise, interpolate between its state and the state of (base + 1).\n  if (base < 0 || base === gameUpdates.length - 1) {\n    return gameUpdates[gameUpdates.length - 1];\n  } else {\n    const baseUpdate = gameUpdates[base];\n    return {\n      me: baseUpdate.me,\n      others: baseUpdate.others,\n      lines: baseUpdate.lines,\n      remainders:baseUpdate.remainders\n    };\n  }\n}\n\n//function interpolateObject(object1, object2, ratio) {\n//  if (!object2) {\n//    return object1;\n//  }\n//\n//  const interpolated = {};\n//  Object.keys(object1).forEach(key => {\n//    if (key === 'direction') {\n//      interpolated[key] = interpolateDirection(object1[key], object2[key], ratio);\n//    } else {\n//      interpolated[key] = object1[key] + (object2[key] - object1[key]) * ratio;\n//    }\n//  });\n//  return interpolated;\n//}\n//\n//function interpolateObjectArray(objects1, objects2, ratio) {\n//  return objects1.map(o => interpolateObject(o, objects2.find(o2 => o.id === o2.id), ratio));\n//}\n\n\n//function interpolateDirection(d1, d2, ratio) {\n//  const absD = Math.abs(d2 - d1);\n//  if (absD >= Math.PI) {\n//    // The angle between the directions is large - we should rotate the other way\n//    if (d1 > d2) {\n//      return d1 + (d2 + 2 * Math.PI - d1) * ratio;\n//    } else {\n//      return d1 - (d2 - 2 * Math.PI - d1) * ratio;\n//    }\n//  } else {\n//    // Normal interp\n//    return d1 + (d2 - d1) * ratio;\n//  }\n//}"],"mappings":"AAAA,MAAMA,YAAY,GAAG,GAAG;AAExB,MAAMC,WAAW,GAAG,EAAE;AACtB,IAAIC,SAAS,GAAG,CAAC;AACjB,IAAIC,oBAAoB,GAAG,CAAC;AAE5B,OAAO,SAASC,SAASA,CAAA,EAAG;EAC1BF,SAAS,GAAG,CAAC;EACbC,oBAAoB,GAAG,CAAC;AAC1B;AAEA,OAAO,SAASE,iBAAiBA,CAACC,MAAM,EAAE;EACxC,IAAI,CAACH,oBAAoB,EAAE;IACzBA,oBAAoB,GAAGG,MAAM,CAACC,CAAC;IAC/BL,SAAS,GAAGM,IAAI,CAACC,GAAG,CAAC,CAAC;EACxB;EACAR,WAAW,CAACS,IAAI,CAACJ,MAAM,CAAC;EACxB,MAAMK,IAAI,GAAGC,aAAa,CAAC,CAAC;EAC5B,IAAID,IAAI,GAAG,CAAC,EAAE;IACZV,WAAW,CAACY,MAAM,CAAC,CAAC,EAAEF,IAAI,CAAC;EAC7B;AACF;AAEA,SAASG,iBAAiBA,CAAA,EAAG;EAC3B,OAAOX,oBAAoB,IAAIK,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGP,SAAS,CAAC,GAAGF,YAAY;AACvE;AAGA,SAASY,aAAaA,CAAA,EAAG;EACvB,MAAMG,UAAU,GAAGD,iBAAiB,CAAC,CAAC;EACtC,KAAK,IAAIE,CAAC,GAAGf,WAAW,CAACgB,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAChD,IAAIf,WAAW,CAACe,CAAC,CAAC,CAACT,CAAC,IAAIQ,UAAU,EAAE;MAClC,OAAOC,CAAC;IACV;EACF;EACA,OAAO,CAAC,CAAC;AACX;AAGA,OAAO,SAASE,eAAeA,CAAA,EAAG;EAChC,IAAI,CAACf,oBAAoB,EAAE;IACzB,OAAO,CAAC,CAAC;EACX;EACA,MAAMQ,IAAI,GAAGC,aAAa,CAAC,CAAC;EAC5B;EACA;EACA,IAAID,IAAI,GAAG,CAAC,IAAIA,IAAI,KAAKV,WAAW,CAACgB,MAAM,GAAG,CAAC,EAAE;IAC/C,OAAOhB,WAAW,CAACA,WAAW,CAACgB,MAAM,GAAG,CAAC,CAAC;EAC5C,CAAC,MAAM;IACL,MAAME,UAAU,GAAGlB,WAAW,CAACU,IAAI,CAAC;IACpC,OAAO;MACLS,EAAE,EAAED,UAAU,CAACC,EAAE;MACjBC,MAAM,EAAEF,UAAU,CAACE,MAAM;MACzBC,KAAK,EAAEH,UAAU,CAACG,KAAK;MACvBC,UAAU,EAACJ,UAAU,CAACI;IACxB,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}