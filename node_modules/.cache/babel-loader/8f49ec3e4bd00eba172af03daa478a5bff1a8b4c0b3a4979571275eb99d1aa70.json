{"ast":null,"code":"const RENDER_DELAY=100;const gameUpdates=[];let gameStart=0;let firstServerTimestamp=0;export function initState(){gameStart=0;firstServerTimestamp=0;}export function processGameUpdate(update){if(!firstServerTimestamp){firstServerTimestamp=update.t;gameStart=Date.now();}gameUpdates.push(update);const base=getBaseUpdate();if(base>0){gameUpdates.splice(0,base);}}function currentServerTime(){return firstServerTimestamp+(Date.now()-gameStart)-RENDER_DELAY;}function getBaseUpdate(){const serverTime=currentServerTime();for(let i=gameUpdates.length-1;i>=0;i--){if(gameUpdates[i].t<=serverTime){return i;}}return-1;}export function getCurrentState(){if(!firstServerTimestamp){return{};}const base=getBaseUpdate();// If base is the most recent update we have, use its state.\n// Otherwise, interpolate between its state and the state of (base + 1).\nif(base<0||base===gameUpdates.length-1){return gameUpdates[gameUpdates.length-1];}else{const baseUpdate=gameUpdates[base];return{me:baseUpdate.me,others:baseUpdate.others,lines:baseUpdate.lines,remainders:baseUpdate.remainders,usernames:baseUpdate.usernames};}}//function interpolateObject(object1, object2, ratio) {\n//  if (!object2) {\n//    return object1;\n//  }\n//\n//  const interpolated = {};\n//  Object.keys(object1).forEach(key => {\n//    if (key === 'direction') {\n//      interpolated[key] = interpolateDirection(object1[key], object2[key], ratio);\n//    } else {\n//      interpolated[key] = object1[key] + (object2[key] - object1[key]) * ratio;\n//    }\n//  });\n//  return interpolated;\n//}\n//\n//function interpolateObjectArray(objects1, objects2, ratio) {\n//  return objects1.map(o => interpolateObject(o, objects2.find(o2 => o.id === o2.id), ratio));\n//}\n//function interpolateDirection(d1, d2, ratio) {\n//  const absD = Math.abs(d2 - d1);\n//  if (absD >= Math.PI) {\n//    // The angle between the directions is large - we should rotate the other way\n//    if (d1 > d2) {\n//      return d1 + (d2 + 2 * Math.PI - d1) * ratio;\n//    } else {\n//      return d1 - (d2 - 2 * Math.PI - d1) * ratio;\n//    }\n//  } else {\n//    // Normal interp\n//    return d1 + (d2 - d1) * ratio;\n//  }\n//}","map":{"version":3,"names":["RENDER_DELAY","gameUpdates","gameStart","firstServerTimestamp","initState","processGameUpdate","update","t","Date","now","push","base","getBaseUpdate","splice","currentServerTime","serverTime","i","length","getCurrentState","baseUpdate","me","others","lines","remainders","usernames"],"sources":["/home/edi/secario.fun/frondend/src/services/state.js"],"sourcesContent":["const RENDER_DELAY = 100;\n\nconst gameUpdates = [];\nlet gameStart = 0;\nlet firstServerTimestamp = 0;\n\nexport function initState() {\n  gameStart = 0;\n  firstServerTimestamp = 0;\n}\n\nexport function processGameUpdate(update) {\n  if (!firstServerTimestamp) {\n    firstServerTimestamp = update.t;\n    gameStart = Date.now();\n  }\n  gameUpdates.push(update);\n  const base = getBaseUpdate();\n  if (base > 0) {\n    gameUpdates.splice(0, base);\n  }\n}\n\nfunction currentServerTime() {\n  return firstServerTimestamp + (Date.now() - gameStart) - RENDER_DELAY;\n}\n\n\nfunction getBaseUpdate() {\n  const serverTime = currentServerTime();\n  for (let i = gameUpdates.length - 1; i >= 0; i--) {\n    if (gameUpdates[i].t <= serverTime) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n\nexport function getCurrentState() {\n  if (!firstServerTimestamp) {\n    return {};\n  }\n  const base = getBaseUpdate();\n  // If base is the most recent update we have, use its state.\n  // Otherwise, interpolate between its state and the state of (base + 1).\n  if (base < 0 || base === gameUpdates.length - 1) {\n    return gameUpdates[gameUpdates.length - 1];\n  } else {\n    const baseUpdate = gameUpdates[base];\n    return {\n      me: baseUpdate.me,\n      others: baseUpdate.others,\n      lines: baseUpdate.lines,\n      remainders: baseUpdate.remainders,\n      usernames: baseUpdate.usernames\n    };\n  }\n}\n\n//function interpolateObject(object1, object2, ratio) {\n//  if (!object2) {\n//    return object1;\n//  }\n//\n//  const interpolated = {};\n//  Object.keys(object1).forEach(key => {\n//    if (key === 'direction') {\n//      interpolated[key] = interpolateDirection(object1[key], object2[key], ratio);\n//    } else {\n//      interpolated[key] = object1[key] + (object2[key] - object1[key]) * ratio;\n//    }\n//  });\n//  return interpolated;\n//}\n//\n//function interpolateObjectArray(objects1, objects2, ratio) {\n//  return objects1.map(o => interpolateObject(o, objects2.find(o2 => o.id === o2.id), ratio));\n//}\n\n\n//function interpolateDirection(d1, d2, ratio) {\n//  const absD = Math.abs(d2 - d1);\n//  if (absD >= Math.PI) {\n//    // The angle between the directions is large - we should rotate the other way\n//    if (d1 > d2) {\n//      return d1 + (d2 + 2 * Math.PI - d1) * ratio;\n//    } else {\n//      return d1 - (d2 - 2 * Math.PI - d1) * ratio;\n//    }\n//  } else {\n//    // Normal interp\n//    return d1 + (d2 - d1) * ratio;\n//  }\n//}"],"mappings":"AAAA,KAAM,CAAAA,YAAY,CAAG,GAAG,CAExB,KAAM,CAAAC,WAAW,CAAG,EAAE,CACtB,GAAI,CAAAC,SAAS,CAAG,CAAC,CACjB,GAAI,CAAAC,oBAAoB,CAAG,CAAC,CAE5B,MAAO,SAAS,CAAAC,SAASA,CAAA,CAAG,CAC1BF,SAAS,CAAG,CAAC,CACbC,oBAAoB,CAAG,CAAC,CAC1B,CAEA,MAAO,SAAS,CAAAE,iBAAiBA,CAACC,MAAM,CAAE,CACxC,GAAI,CAACH,oBAAoB,CAAE,CACzBA,oBAAoB,CAAGG,MAAM,CAACC,CAAC,CAC/BL,SAAS,CAAGM,IAAI,CAACC,GAAG,CAAC,CAAC,CACxB,CACAR,WAAW,CAACS,IAAI,CAACJ,MAAM,CAAC,CACxB,KAAM,CAAAK,IAAI,CAAGC,aAAa,CAAC,CAAC,CAC5B,GAAID,IAAI,CAAG,CAAC,CAAE,CACZV,WAAW,CAACY,MAAM,CAAC,CAAC,CAAEF,IAAI,CAAC,CAC7B,CACF,CAEA,QAAS,CAAAG,iBAAiBA,CAAA,CAAG,CAC3B,MAAO,CAAAX,oBAAoB,EAAIK,IAAI,CAACC,GAAG,CAAC,CAAC,CAAGP,SAAS,CAAC,CAAGF,YAAY,CACvE,CAGA,QAAS,CAAAY,aAAaA,CAAA,CAAG,CACvB,KAAM,CAAAG,UAAU,CAAGD,iBAAiB,CAAC,CAAC,CACtC,IAAK,GAAI,CAAAE,CAAC,CAAGf,WAAW,CAACgB,MAAM,CAAG,CAAC,CAAED,CAAC,EAAI,CAAC,CAAEA,CAAC,EAAE,CAAE,CAChD,GAAIf,WAAW,CAACe,CAAC,CAAC,CAACT,CAAC,EAAIQ,UAAU,CAAE,CAClC,MAAO,CAAAC,CAAC,CACV,CACF,CACA,MAAO,CAAC,CAAC,CACX,CAGA,MAAO,SAAS,CAAAE,eAAeA,CAAA,CAAG,CAChC,GAAI,CAACf,oBAAoB,CAAE,CACzB,MAAO,CAAC,CAAC,CACX,CACA,KAAM,CAAAQ,IAAI,CAAGC,aAAa,CAAC,CAAC,CAC5B;AACA;AACA,GAAID,IAAI,CAAG,CAAC,EAAIA,IAAI,GAAKV,WAAW,CAACgB,MAAM,CAAG,CAAC,CAAE,CAC/C,MAAO,CAAAhB,WAAW,CAACA,WAAW,CAACgB,MAAM,CAAG,CAAC,CAAC,CAC5C,CAAC,IAAM,CACL,KAAM,CAAAE,UAAU,CAAGlB,WAAW,CAACU,IAAI,CAAC,CACpC,MAAO,CACLS,EAAE,CAAED,UAAU,CAACC,EAAE,CACjBC,MAAM,CAAEF,UAAU,CAACE,MAAM,CACzBC,KAAK,CAAEH,UAAU,CAACG,KAAK,CACvBC,UAAU,CAAEJ,UAAU,CAACI,UAAU,CACjCC,SAAS,CAAEL,UAAU,CAACK,SACxB,CAAC,CACH,CACF,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}